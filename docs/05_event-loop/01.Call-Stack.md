# Call Stack

# 콜 스택

콜 스택(Call Stack)은 **함수 호출 정보를 저장하는 자료 구조**로, JavaScript가 **함수를 어떤 순서로 실행하고 종료할지를 관리**하는 핵심 메커니즘이다.

JavaScript는 싱글 스레드 기반 언어이므로, 하나의 콜 스택에서 모든 작업을 순차적으로 처리한다.

---

## 1. 콜 스택 동작 원리

JavaScript는 **함수를 호출하면 콜 스택에 쌓고 return 시 제거하는 방식**으로 동작한다. 즉, 후입선출(Last In, First Out, LIFO)방식으로 작동하는 스택 구조다.

```jsx
function a() {
  console.log("A");
  b();
  console.log("A-end");
}

function b() {
  console.log("B");
  c();
}

function c() {
  console.log("C");
}

a();
```

- `a()` 함수가 호출되면서 콜 스택에 `a`가 쌓임.
- `a()` 내부에서 `b()`를 호출 → `b`도 콜 스택에 쌓임.
- `b()` 내부에서 `c()`를 호출 → `c`도 콜 스택에 쌓임.
- `c()`가 실행되면 `console.log("C")` 실행 후 종료 → 콜 스택에서 제거(pop)
- `b()`의 나머지 코드가 없으므로 종료 → 콜 스택에서 제거(pop)
- `a()`는 마지막으로 `console.log("A-end")` 실행 후 종료 → 콜 스택에서 제거(pop)

---

## 2. 콜 스택 시각화 (실행 시점 기준)

```jsx
Stack 상태 (위가 top)
------------------------
| c()                  | ← 실행 중
| b()                  |
| a()                  |
------------------------
```

- 위 그림은 `c()`가 실행 중일 때의 콜 스택 상태를 나타낸다.

---

## 3. 콜 스택 초과 - Stack Overflow

스택이 너무 많이 쌓이면 **스택 오버플로우 오류**가 발생할 수 있다.

재귀 함수의 종료 조건이 없을 경우, 무한 호출로 인해 메모리가 넘쳐 오류가 발생한다.

```jsx
function infinite() {
  return infinite();
}

infinite(); // RangeError: Maximum call stack size exceeded
```

- `infinite()` 함수는 자신을 계속 재귀 호출하지만 종료 조건이 없다.
- 이로 인해 콜 스택에 함수가 계속 쌓이기만 하고 제거되지 않는다.
- 결국 브라우저가 감당할 수 있는 최대 호출 깊이를 초과하며 오류가 발생한다.

---

## 4. React에서의 콜 스택 인식

- 리렌더링 시 무한 루프 발생 등은 내부적으로 콜 스택이 과도하게 쌓인 결과일 수 있다.
- 특히 상태 변경 → 렌더링 → 상태 변경 → ... 패턴이 반복되면 Stack Overflow가 발생할 수 있다.

### 예제: useEffect 무한 호출

```jsx
useEffect(() => {
  setCount(count + 1);
}, [count]);
```

- `count`가 변경되면 `useEffect`가 실행된다.
- `setCount`로 다시 `count`를 변경하면 다시 `useEffect`가 실행된다.
- 이 과정을 무한 반복하게 되면 콜 스택이 계속 쌓이고 브라우저가 중단한다.
- 의존성 배열을 올바르게 설정하지 않으면 이런 무한 호출이 발생할 수 있다.

---

## 5. 결론

- 콜 스택은 자바스크립트에서 **함수 실행 순서를 추적하고 관리하는 핵심 구조**이다.
- 모든 함수 호출은 콜 스택에 쌓이고, 종료되면 제거되는 방식으로 순차적으로 실행된다.
- React에서도 무한 렌더링 오류나 재귀적 로직이 콜 스택 과도 누적으로 이어질 수 있으므로, 이를 잘 이해하고 있어야 한다.
- 콜 스택의 동작 원리를 이해하면 디버깅, 재귀함수, 비동기 처리에서 발생할 수 있는 문제들을 더 쉽게 추적하고 해결할 수 있다.